//Swagger2 API - Decoration
var metadata = require('../metamodel');

var geopointFound = false;
var appHasFileServices = false;

function decorateApi(baucisInstance, options) {
	options = options || {};
	baucisInstance.swagger2Document.info.title = options.title || "api";
	baucisInstance.swagger2Document.info.description = options.description || 
	        "Microservice API generated by [Hivepod](https://hivepod.io)";

	if (options.host) {
		baucisInstance.swagger2Document.info.host = options.host;
	}
	if (options.termsOfService){
		baucisInstance.swagger2Document.info.termsOfService = options.termsOfService;
	}
	if (options.contact){
		baucisInstance.swagger2Document.info.contact = options.contact;
	}
	if (options.license){
		baucisInstance.swagger2Document.info.license = options.license;
	}
	if (options.version){
		baucisInstance.swagger2Document.info.version = options.version;
	}
	//extensions
	baucisInstance.swagger2Document.info['x-generated-by'] = 'hivepod-io';
	baucisInstance.swagger2Document.info['x-powered-by'] = 'baucis';
	baucisInstance.swagger2Document.info['x-model-types-namespace'] = 'icinetic.types.v1';

	markAdminResources(baucisInstance.swagger2Document.tags);

	addSecurity(baucisInstance.swagger2Document);
	addDiagnosticOperations(baucisInstance.swagger2Document);
	fixPrecisionOnTypes(baucisInstance.swagger2Document);
}

function fixPrecisionOnTypes(sw) {
	var col = sw.definitions;
	for (var key in col) {
   		if (col.hasOwnProperty(key)) {
       		var def = col[key];
       		fixPrecisionOnType(key, def);
        }
    }
}

function fixPrecisionOnType(className, def) {
	var cl = metadata.getClassByName(className);
	if (!cl) {
		return;
	}
	var col = def.properties;
	for (var key in col) {
   		if (col.hasOwnProperty(key)) {
       		var prop = col[key];
       		fixPrecisionOnProperty(cl, key, prop);
        }
    }
}

function fixPrecisionOnProperty(cl, propName, prop) {
	var propInfo = cl.getAttributeByName(propName);
	if (!propInfo) {
		return;
	}
	prop['x-model-type'] = propInfo.type; //model type extension: original modeled type

	if ('int' === propInfo.type) {
		prop.type = 'integer';		
		prop.format = 'int32';		
	}
	else if ('long' === propInfo.type) {
		prop.type = 'integer';		
		prop.format = 'int64';		
	}
	else if ('float' === propInfo.type) {
		prop.type = 'number';		
		prop.format = 'float';		
	}
	else if ('decimal' === propInfo.type) {
		prop.type = 'number';		
		prop.format = 'double';		
	}
	else if ('byte' === propInfo.type) {
		prop.type = 'string';		
		prop.format = 'byte';		
	}
	else if ('password' === propInfo.type) {
		prop.type = 'string';		
		prop.format = 'password';	
	}
	else if ('boolean' === propInfo.type) {
		prop.type = 'boolean';		
	}
	else if ('date' === propInfo.type) {
		prop.type = 'string';		
		prop.format = 'date';		
	}
	else if ('datetime' === propInfo.type) {
		prop.type = 'string';		
		prop.format = 'date-time';		
	}
	else if ('time' === propInfo.type) {
		prop.type = 'string';		
		prop.format = 'date-time';	//No special time format in Swagger 2.0	
	}
	else if ('html' === propInfo.type) {
		prop.type = 'string';	//No special format for html in Swagger 2.0	
	}
}


function addDiagnosticOperations(sw) {
	sw.tags.push({
		name: '_diagnostics',
		description: "Diagnostics and health check.",
		'x-resource': true,
		'x-admin-resource': true
	});
	sw.paths['/status'] = {
		get: {
			operationId: 'status',
			summary: 'Operational Status.',
			description: 'Used to report diagnostics and monitoring the service.',
			tags: [ '_diagnostics' ],
			responses: {
				"200": {
					description: 'Status Ok.',
					schema: {
						$ref: '#/definitions/_status'
					}
				},
				"default": {
					description: 'Status Error.',
					schema: {
						$ref: '#/definitions/_status'
					}
				}
			}
		}
	};
	sw.definitions._status = {
		required: [ 'status' ],
		properties: {
			status: {
				type: "string"
			}
		}
	};
}

function addSecurity(swRoot) {
	swRoot.securityDefinitions = {
        basic: {
            type: 'basic'
        },
        apikey: {
            type: 'apiKey',
            name: 'apikey',
            in: 'header'
        }
    };
    swRoot.security = [{
     	basic: [] 
    }, {
    	apikey: []
 	}];
}

function markAdminResources(tags) {
	if (!tags) {
		return;
	}
	tags.forEach(function(tag) {
		if (tag.name[0] === '_') {
			//it's an admin-resource
			tag['x-admin-resource'] = true;
			tag.description = tag.name +" admin resource.";
		}
	});
}

function fixSwaggerForFileServices(clInfo, controller) {
	//post & put: consumes now multipart/form-data. change swagger spec accordingly
	var binProps = clInfo.getBinaryProperties();
	if (binProps.length === 0) {
		return;
	}	
	var routePost = '/' + controller.model().plural();
	var postOp = controller.swagger2.paths[routePost].post;

	var routePut = routePost + '/{id}';
	var putOp = controller.swagger2.paths[routePut].put;
	fixSwaggerForFileServicesOperation(postOp, clInfo, binProps, controller);	
	fixSwaggerForFileServicesOperation(putOp, clInfo, binProps, controller);
	appHasFileServices = true;	
}

function fixSwaggerForFileServicesOperation(op, clInfo, binProps, controller) {
	op.consumes = ['multipart/form-data'];
	op.parameters = op.parameters || [];
	removeItem(op.parameters, 'name', 'document');
	op.parameters.push({
		name: 'data',
		in: 'formData',
		type: 'file', //<-lack of swagger expressivenes. Type info via an extension param.
		//type: {
		//	$ref: '#/definitions/'+controller.model().singular()
		//},
		'x-schema-ref': '#/definitions/' + controller.model().singular(),  //Custom Extension to Swagger
		description: 'Resource payoad.',
		required: true
	});
	binProps.forEach(function(prop){
		op.parameters.push({
			name: camelize(prop.name),
			in: 'formData',
			type: 'file',
			description: prop.name + ' as a file attachment.',
			required: prop.required,
			allowEmptyValue: prop.required
		});
	});
}

function removeItem(col, prop, value) {
	for(var i=0; i<col.length; i++) {
		var item = col[i];
		if (item[prop] == value) {
			col.splice(i,1); //remove item
			return;
		}
	}
}

function removeFromArray(array, item) {
	var index = array.indexOf(item);
	if (index !== -1) {
		array.splice(index, 1);
	}
}

function addDeleteMany(controller, resourceName) {
    controller.swagger2.paths['/' + controller.model().plural() + '/deleteByIds'] = {
		post: {
			operationId: 'deleteByIds',
			summary: 'Delete all the objects matching the ids provided.',
			description: 'Delete a set of object in one shot.',
			tags: [ camelize(resourceName) ],
			parameters: [{
				name: 'document',
				in: 'body',
				description: 'Array of Ids to delete.',
				schema: {
					type: 'array',
					items: {
						type: 'string' 
					}
				},
				required: true 
			}],
			responses: {
				'202': {
					description: 'Accepted for deletion.'
				},
				'412': {
					description: 'Array of ids was not provided.'
				},
				default: {
					description: 'Generic error.'
				}
			}
		}
	};
}

function getResourceName(controller) {
	var col = controller.swagger2.definitions;
	for (var key in col) {
   		if (col.hasOwnProperty(key)) {
       		return key; //return the name of the first one
        }
    }
    return null;
}



function fixGeoPointProperties(controller, clInfo) {
	var geopointProperties = clInfo.filterPropertiesWithType('geopoint');
	if (geopointProperties.length === 0) {
		return;
	}
	geopointProperties.forEach(function(prop) {
		fixGeopointPaths(controller, prop, clInfo);
	});	
}
function fixGeopointPaths(controller, prop, clInfo) {
	var basePathName = camelize(prop.name);
	var propTypeName = basePathName + '.type';
	var propCoordinatesName = basePathName + '.coordinates';
	
	var definition = findDefinition(controller, capitalize(clInfo.name));
	if (!definition) {
		return;
	}
	//var propType = findSchemaProperty(definition, propTypeName);
	//var propCoordinates = findSchemaProperty(definition, propCoordinatesName);	
	//fix property
	delete definition.properties[propTypeName];
	delete definition.properties[propCoordinatesName];
	definition.properties[basePathName] = {
		$ref: '#/definitions/GeoJsonPoint',
		'x-model-type': 'geopoint'
	};
	//fix required
	var isRequired = contains(definition.required, propTypeName);
	if (isRequired) {
		removeFromArray(definition.required, propTypeName);
		removeFromArray(definition.required, propCoordinatesName);
		definition.required.push(basePathName);
	}
	geopointFound = true;
}
function findDefinition(controller, className) {
	return findObjectProperty(controller.swagger2.definitions, className);
}
function findObjectProperty(object, propertyName) {
	if (!object) {
		return null;
	}
	for (var key in object) {
   		if (object.hasOwnProperty(key)) {
       		if (key === propertyName) {
       			return object[key];
       		}
        }
    }
    return null;
}
function addGeopointType(swaggerDoc) {
	swaggerDoc.definitions.GeoJsonPoint = {
		required : [ 'type', 'coordinates' ],
		properties: {
			type: {
				type: 'string',
				default: 'Point'
			},
			coordinates: {
				type: 'array',
				items: {
					type: 'number',
					format: 'double'
				},
				maximum: 2,
				minimum: 2					
			}
		}
	};
}

function contains(collection, itemValue) {
	if (!collection) {
		return false;
	}
	for (var i = 0; i < collection.length; i++) {
		var item = collection[i];
		if (item === itemValue) {
			return true;
		}
    }
	return false;
}

function capitalize(s) {
	if (!s) { 
		return s; 
	}
	if (s.length === 1) {
		return s.toUpperCase();
	}
	return s[0].toUpperCase() + s.substring(1);
}
function camelize(s) {
	if (!s) { 
		return s; 
	}
	if (s.length === 1) {
		return s.toLowerCase();
	}
	return s[0].toLowerCase() + s.substring(1);
}


function addControllerSwagger2Doc(controller, options) {
	//extend your swagger 2.0 here using: 
	//  controller.swagger2.paths.xyz = '123';
	//  controller.swagger2.definitions.xyz = {};

	var resourceName = getResourceName(controller);
	var clInfo = metadata.getClassByName(resourceName);
	if (!clInfo) {
		return;
	}
	fixGeoPointProperties(controller, clInfo);
	fixSwaggerForFileServices(clInfo, controller);

	addDeleteMany(controller, camelize(resourceName));
}

function exposePathForBinaryContent(sw2Doc) {
	sw2Doc.tags.push({
		name: 'binary',
		description: 'Generic resource for serving all binary files.',
		'x-resource': true
	});
	sw2Doc.paths['/binary/{fileName}'] = {
		get: {
			operationId: 'getBinaryFile',
			summary: 'Provides access to the content of a binary file.',
			description: 'Downloads the filename.',
			tags: ['binary'],
			parameters: [{
				name: 'fileName',
				in: 'path',
				description: 'The filename or key for the file to be retrieved.',
				type: 'string',
				required: true
			}],
			produces: ['application/octet-stream'],
			responses: {
				'200': {
					description: 'Sucessful. File content delivered.'
				},
				'404': {
					description: 'File not found.',
					schema: {
						type: 'string'
					}
				},
				default: {
					description: 'Unexpected error.',
					schema: {
						type: 'string'
					}
				}
			}
		}
	};
}

function addRelationSwagger2Doc(association, controllers) {
    var sourceController = getController(controllers, association.aClass);
    var targetController = getController(controllers, association.bClass);

	if (association.composition) {
		if (!association.isSourceOptional() && sourceController) {
			var singular = sourceController.model().singular();
			var def = sourceController.swagger2.definitions[capitalize(singular)];
			if (def) {
				def.required.push(association.aRole);
			}
		}
		return;
	}

	if(!sourceController || !targetController) {
		return;
	}

    if (association.isSourceMultiple() && association.isTargetMultiple()) { // [Many to Many]
        buildManyRoleDocs(sourceController, association.bClass, association.aRole, false, association.isTargetOptional(), association.isSourceOptional());
        buildManyRoleDocs(targetController, association.aClass, association.bRole, false, association.isSourceOptional(), association.isTargetOptional());
    }
    else if (!association.isSourceMultiple() && !association.isTargetMultiple()) { // [One to One]
        if (association.isSourceOptional()) {
            buildManyRoleDocs(sourceController, association.bClass, association.aRole, true, association.isTargetOptional(), association.isSourceOptional());
            buildOneCardinalityApis(targetController, association.bClass, association.aClass, association.bRole, association.aRole);
        }
        else {
            buildOneCardinalityApis(sourceController, association.aClass, association.bClass, association.aRole, association.bRole);
            buildManyRoleDocs(targetController, association.aClass, association.bRole, true, association.isSourceOptional(), association.isTargetOptional());
        }
    }
    else { // [One to Many], [Many to One]
        if (association.isSourceMultiple()) {
            buildManyRoleDocs(sourceController, association.bClass, association.aRole, false, association.isTargetOptional(), association.isSourceOptional());
        }
        else {
            buildOneCardinalityApis(sourceController, association.aClass, association.bClass, association.aRole, association.bRole);
        }
        if (association.isTargetMultiple()) {
            buildManyRoleDocs(targetController, association.aClass, association.bRole, false, association.isSourceOptional(), association.isTargetOptional());
        }
        else {
            buildOneCardinalityApis(targetController, association.bClass, association.aClass, association.bRole, association.aRole);
        }
    }
}

function buildManyRoleDocs(controller, targetName, sourceRole, singleResult, optional, oppositeOptional) {
    var singular = controller.model().singular();
    var plural = controller.model().plural();
	var def = controller.swagger2.definitions[capitalize(singular)];
	if (def) {
		def.properties[sourceRole] = {
			type: 'array',
			items: {
				type: 'string',
				'x-ref': '#/definitions/' + capitalize(targetName)
			}
		};
		if (!oppositeOptional) {
			def.required.push(sourceRole);
		}
	}

    controller.swagger2.paths['/' + plural + '/{id}/' + sourceRole] = {
        parameters: [
			getIdParameter(capitalize(singular))
        ],
        get: {
            operationId: 'get' + capitalize(singular) + capitalize(sourceRole),
            summary: 'Retrieves the linked ' + sourceRole + '.',
            description: 'Retrieves the linked ' + sourceRole + '.',
            tags: [camelize(singular)],
            responses: {
                200: getSuccessCollectionResponse(capitalize(targetName)),
                404: getNotFoundResponse(capitalize(singular)),
                default: getDefaultResponse()
            }
        },
        post: {
            operationId: 'add' + capitalize(sourceRole) + 'To' + capitalize(singular),
            summary: 'Link ' + capitalize(targetName) + (singleResult ? '' : '(s)') + '.',
            description: 'Link ' + capitalize(targetName) + (singleResult ? '' : '(s)') + '.',
            tags: [camelize(singular)],
            parameters: [
				getIdsParameter(targetName)
            ],
            responses: {
                200: getSuccessSingleResponse(capitalize(singular)),
                404: getNotFoundResponse(capitalize(singular)),
                default: getDefaultResponse()
            }
        }
    };

    if (optional && !singleResult) {
        controller.swagger2.paths['/' + plural + '/{id}/' + sourceRole].put = {
            operationId: 'set' + capitalize(singular) + capitalize(sourceRole),
            summary: 'Set the linked ' + sourceRole + '.',
            description: 'Set the linked ' + sourceRole + '.',
            tags: [camelize(singular)],
            parameters: [
				getIdsParameter(targetName)
            ],
            responses: {
                200: getSuccessSingleResponse(capitalize(singular)),
                404: getNotFoundResponse(capitalize(singular)),
                default: getDefaultResponse()
            }
        };
    }

    if (optional) {
        controller.swagger2.paths['/' + plural + '/{id}/' + sourceRole + '/{' + targetName + 'Id}'] = {
            parameters: [
				getIdParameter(capitalize(singular)),
				getLinkedIdParameter(capitalize(targetName))
            ],
            delete: {
                operationId: 'unlink' + capitalize(sourceRole) + 'From' + capitalize(singular),
                summary: 'Unlink the specified ' + capitalize(targetName) + '.',
                description: 'Unlink the specified ' + capitalize(targetName) + '.',
                tags: [camelize(singular)],
                responses: {
                    200: getSuccessSingleResponse(capitalize(singular)),
                    404: getNotFoundResponse(capitalize(singular)),
                    default: getDefaultResponse()
                }
            }
        };
    }
}

function buildOneCardinalityApis(controller, sourceName, targetName, sourceRole, targetRole) {
    controller.swagger2.definitions._bodyIdParameter = {
        required: [
			"id"
        ],
        properties: {
            id: {
                type: "string"
            }
        }
    };

    var singular = controller.model().singular();
    var plural = controller.model().plural();
    controller.swagger2.paths['/' + plural + '/{id}/' + sourceRole] = {
        parameters: [
			getIdParameter(capitalize(singular))
        ],
        get: {
            operationId: 'get' + capitalize(singular) + capitalize(sourceRole),
            summary: 'Retrieves the linked ' + sourceRole + '.',
            description: 'Retrieves the linked ' + sourceRole + '.',
            tags: [camelize(singular)],
            responses: {
                200: getSuccessSingleResponse(capitalize(targetName)),
                404: getNotFoundResponse(capitalize(singular)),
                default: getDefaultResponse()
            }
        },
        post: {
            operationId: 'Set' + capitalize(singular) + capitalize(sourceRole),
            summary: 'Link ' + capitalize(targetName) + '.',
            description: 'Link ' + capitalize(targetName) + '.',
            tags: [camelize(singular)],
            parameters: [
				getBodyIdParameter(targetName)
            ],
            responses: {
                200: getSuccessSingleResponse(capitalize(singular)),
                404: getNotFoundResponse(capitalize(singular)),
                default: getDefaultResponse()
            }
        }
    };

    controller.swagger2.paths['/' + plural + '/{id}/' + sourceRole + '/{' + targetName + 'Id}'] = {
        parameters: [
			getIdParameter(capitalize(singular)),
			getLinkedIdParameter(capitalize(targetName))
        ],
        delete: {
            operationId: 'unlink' + capitalize(sourceRole) + 'From' + capitalize(singular),
            summary: 'Unlink the specified ' + capitalize(targetName) + '.',
            description: 'Unlink the specified ' + capitalize(targetName) + '.',
            tags: [camelize(singular)],
            responses: {
                200: getSuccessSingleResponse(capitalize(singular)),
                404: getNotFoundResponse(capitalize(singular)),
                default: getDefaultResponse()
            }
        }
    };
}

function getController(controllers, singularName) {
    var selectedController = null;
    controllers.forEach(function (controller) {
        if (controller.model().singular() === singularName) {
            selectedController = controller;
            return;
        }
    });

    return selectedController;
}

function getDefaultResponse() {
    return {
        description: 'Unexpected error.',
        schema: {
            type: 'string'
        }
    };
}

function getNotFoundResponse(resource) {
    return {
        description: 'No ' + resource + ' matched that ID.',
        schema: {
            type: 'string'
        }
    };
}

function getSuccessSingleResponse(resource) {
    return {
        description: 'Sucessful response. Single resource.',
        schema: {
            $ref: '#/definitions/' + resource
        }
    };
}

function getSuccessCollectionResponse(resource) {
    return {
        description: 'Sucessful response. Collection of resources.',
        schema: {
            type: 'array',
            items: {
                $ref: '#/definitions/' + resource
            }
        }
    };
}

function getIdParameter(resource) {
    return {
        name: 'id',
        in: 'path',
        description: 'The ID of a ' + resource + '.',
        type: 'string',
        required: true
    };
}

function getLinkedIdParameter(resource) {
    return {
        name: camelize(resource) + 'Id',
        in: 'path',
        description: 'The ID of a ' + resource + '.',
        type: 'string',
        required: true
    };
}

function getBodyIdParameter(resource) {
    return {
        name: 'document',
        in: 'body',
        description: 'The ID of a ' + resource + '.',
        schema: {
            $ref: "#/definitions/_bodyIdParameter"
        },
        required: true
    };
}

function getIdsParameter(resource) {
    return {
        name: 'document',
        in: 'body',
        description: 'Array of ' + resource + ' Ids to be linked.',
        schema: {
            type: 'array',
            items: {
                type: 'string'
            }
        },
        required: true
    };
}

function apply(baucisInstance, controllers, options) {
	//decorate Swagger
	baucisInstance.generateSwagger2(baucisInstance);

	//decorate controllers
	decorateApi(baucisInstance, options);
    controllers.forEach(function(controller) { 
        addControllerSwagger2Doc(controller, options); 
    });

    //generate relations API docs
    metadata.associations.forEach(function (association) {
        addRelationSwagger2Doc(association, controllers);
    });

	//post-decotate Swagger doc
    if (geopointFound) {
	    addGeopointType(baucisInstance.swagger2Document); 
    }
	if (appHasFileServices) {
		exposePathForBinaryContent(baucisInstance.swagger2Document);
	}
}

module.exports.apply = apply;